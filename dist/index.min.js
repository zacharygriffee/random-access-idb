
                globalThis.process = {
                    platform: "browser"
                };
            
function blocks(size, start, end) {
    const result = [];
    for (let n = Math.floor(start / size) * size; n < end; n += size) {
        result.push({
            block: Math.floor(n / size),
            start: Math.max(n, start) % size,
            end: Math.min(n + size, end) % size || size
        });
    }
    return result
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var browser = {exports: {}};

function byteLength$4 (string) {
  return string.length
}

function toString$4 (buffer) {
  const len = buffer.byteLength;

  let result = '';

  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buffer[i]);
  }

  return result
}

function write$4 (buffer, string, offset = 0, length = byteLength$4(string)) {
  const len = Math.min(length, buffer.byteLength - offset);

  for (let i = 0; i < len; i++) {
    buffer[offset + i] = string.charCodeAt(i);
  }

  return len
}

var ascii = {
  byteLength: byteLength$4,
  toString: toString$4,
  write: write$4
};

const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

const codes = new Uint8Array(256);

for (let i = 0; i < alphabet.length; i++) {
  codes[alphabet.charCodeAt(i)] = i;
}

codes[/* - */ 0x2d] = 62;
codes[/* _ */ 0x5f] = 63;

function byteLength$3 (string) {
  let len = string.length;

  if (string.charCodeAt(len - 1) === 0x3d) len--;
  if (len > 1 && string.charCodeAt(len - 1) === 0x3d) len--;

  return (len * 3) >>> 2
}

function toString$3 (buffer) {
  const len = buffer.byteLength;

  let result = '';

  for (let i = 0; i < len; i += 3) {
    result += (
      alphabet[buffer[i] >> 2] +
      alphabet[((buffer[i] & 3) << 4) | (buffer[i + 1] >> 4)] +
      alphabet[((buffer[i + 1] & 15) << 2) | (buffer[i + 2] >> 6)] +
      alphabet[buffer[i + 2] & 63]
    );
  }

  if (len % 3 === 2) {
    result = result.substring(0, result.length - 1) + '=';
  } else if (len % 3 === 1) {
    result = result.substring(0, result.length - 2) + '==';
  }

  return result
}
function write$3 (buffer, string, offset = 0, length = byteLength$3(string)) {
  const len = Math.min(length, buffer.byteLength - offset);

  for (let i = 0, j = 0; j < len; i += 4) {
    const a = codes[string.charCodeAt(i)];
    const b = codes[string.charCodeAt(i + 1)];
    const c = codes[string.charCodeAt(i + 2)];
    const d = codes[string.charCodeAt(i + 3)];

    buffer[j++] = (a << 2) | (b >> 4);
    buffer[j++] = ((b & 15) << 4) | (c >> 2);
    buffer[j++] = ((c & 3) << 6) | (d & 63);
  }

  return len
}
var base64 = {
  byteLength: byteLength$3,
  toString: toString$3,
  write: write$3
};

function byteLength$2 (string) {
  return string.length >>> 1
}

function toString$2 (buffer) {
  const len = buffer.byteLength;

  buffer = new DataView(buffer.buffer, buffer.byteOffset, len);

  let result = '';
  let i = 0;

  for (let n = len - (len % 4); i < n; i += 4) {
    result += buffer.getUint32(i).toString(16).padStart(8, '0');
  }

  for (; i < len; i++) {
    result += buffer.getUint8(i).toString(16).padStart(2, '0');
  }

  return result
}

function write$2 (buffer, string, offset = 0, length = byteLength$2(string)) {
  const len = Math.min(length, buffer.byteLength - offset);

  for (let i = 0; i < len; i++) {
    const a = hexValue(string.charCodeAt(i * 2));
    const b = hexValue(string.charCodeAt(i * 2 + 1));

    if (a === undefined || b === undefined) {
      return buffer.subarray(0, i)
    }

    buffer[offset + i] = (a << 4) | b;
  }

  return len
}

var hex = {
  byteLength: byteLength$2,
  toString: toString$2,
  write: write$2
};

function hexValue (char) {
  if (char >= 0x30 && char <= 0x39) return char - 0x30
  if (char >= 0x41 && char <= 0x46) return char - 0x41 + 10
  if (char >= 0x61 && char <= 0x66) return char - 0x61 + 10
}

function byteLength$1 (string) {
  let length = 0;

  for (let i = 0, n = string.length; i < n; i++) {
    const code = string.charCodeAt(i);

    if (code >= 0xd800 && code <= 0xdbff && i + 1 < n) {
      const code = string.charCodeAt(i + 1);

      if (code >= 0xdc00 && code <= 0xdfff) {
        length += 4;
        i++;
        continue
      }
    }

    if (code <= 0x7f) length += 1;
    else if (code <= 0x7ff) length += 2;
    else length += 3;
  }

  return length
}

let toString$1;

if (typeof TextDecoder !== 'undefined') {
  const decoder = new TextDecoder();

  toString$1 = function toString (buffer) {
    return decoder.decode(buffer)
  };
} else {
  toString$1 = function toString (buffer) {
    const len = buffer.byteLength;

    let output = '';
    let i = 0;

    while (i < len) {
      let byte = buffer[i];

      if (byte <= 0x7f) {
        output += String.fromCharCode(byte);
        i++;
        continue
      }

      let bytesNeeded = 0;
      let codePoint = 0;

      if (byte <= 0xdf) {
        bytesNeeded = 1;
        codePoint = byte & 0x1f;
      } else if (byte <= 0xef) {
        bytesNeeded = 2;
        codePoint = byte & 0x0f;
      } else if (byte <= 0xf4) {
        bytesNeeded = 3;
        codePoint = byte & 0x07;
      }

      if (len - i - bytesNeeded > 0) {
        let k = 0;

        while (k < bytesNeeded) {
          byte = buffer[i + k + 1];
          codePoint = (codePoint << 6) | (byte & 0x3f);
          k += 1;
        }
      } else {
        codePoint = 0xfffd;
        bytesNeeded = len - i;
      }

      output += String.fromCodePoint(codePoint);
      i += bytesNeeded + 1;
    }

    return output
  };
}

let write$1;

if (typeof TextEncoder !== 'undefined') {
  const encoder = new TextEncoder();

  write$1 = function write (buffer, string, offset = 0, length = byteLength$1(string)) {
    const len = Math.min(length, buffer.byteLength - offset);
    encoder.encodeInto(string, buffer.subarray(offset, offset + len));
    return len
  };
} else {
  write$1 = function write (buffer, string, offset = 0, length = byteLength$1(string)) {
    const len = Math.min(length, buffer.byteLength - offset);

    buffer = buffer.subarray(offset, offset + len);

    let i = 0;
    let j = 0;

    while (i < string.length) {
      const code = string.codePointAt(i);

      if (code <= 0x7f) {
        buffer[j++] = code;
        i++;
        continue
      }

      let count = 0;
      let bits = 0;

      if (code <= 0x7ff) {
        count = 6;
        bits = 0xc0;
      } else if (code <= 0xffff) {
        count = 12;
        bits = 0xe0;
      } else if (code <= 0x1fffff) {
        count = 18;
        bits = 0xf0;
      }

      buffer[j++] = bits | (code >> count);
      count -= 6;

      while (count >= 0) {
        buffer[j++] = 0x80 | ((code >> count) & 0x3f);
        count -= 6;
      }

      i += code >= 0x10000 ? 2 : 1;
    }

    return len
  };
}

var utf8 = {
  byteLength: byteLength$1,
  toString: toString$1,
  write: write$1
};

function byteLength (string) {
  return string.length * 2
}

function toString (buffer) {
  const len = buffer.byteLength;

  let result = '';

  for (let i = 0; i < len - 1; i += 2) {
    result += String.fromCharCode(buffer[i] + (buffer[i + 1] * 256));
  }

  return result
}

function write (buffer, string, offset = 0, length = byteLength(string)) {
  const len = Math.min(length, buffer.byteLength - offset);

  let units = len;

  for (let i = 0; i < string.length; ++i) {
    if ((units -= 2) < 0) break

    const c = string.charCodeAt(i);
    const hi = c >> 8;
    const lo = c % 256;

    buffer[offset + i * 2] = lo;
    buffer[offset + i * 2 + 1] = hi;
  }

  return len
}

var utf16le = {
  byteLength,
  toString,
  write
};

(function (module, exports) {
	const ascii$1 = ascii;
	const base64$1 = base64;
	const hex$1 = hex;
	const utf8$1 = utf8;
	const utf16le$1 = utf16le;

	const LE = new Uint8Array(Uint16Array.of(0xff).buffer)[0] === 0xff;

	function codecFor (encoding) {
	  switch (encoding) {
	    case 'ascii':
	      return ascii$1
	    case 'base64':
	      return base64$1
	    case 'hex':
	      return hex$1
	    case 'utf8':
	    case 'utf-8':
	    case undefined:
	      return utf8$1
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return utf16le$1
	    default:
	      throw new Error(`Unknown encoding: ${encoding}`)
	  }
	}

	function isBuffer (value) {
	  return value instanceof Uint8Array
	}

	function isEncoding (encoding) {
	  try {
	    codecFor(encoding);
	    return true
	  } catch {
	    return false
	  }
	}

	function alloc (size, fill, encoding) {
	  const buffer = new Uint8Array(size);
	  if (fill !== undefined) exports.fill(buffer, fill, 0, buffer.byteLength, encoding);
	  return buffer
	}

	function allocUnsafe (size) {
	  return new Uint8Array(size)
	}

	function allocUnsafeSlow (size) {
	  return new Uint8Array(size)
	}

	function byteLength (string, encoding) {
	  return codecFor(encoding).byteLength(string)
	}

	function compare (a, b) {
	  if (a === b) return 0

	  const len = Math.min(a.byteLength, b.byteLength);

	  a = new DataView(a.buffer, a.byteOffset, a.byteLength);
	  b = new DataView(b.buffer, b.byteOffset, b.byteLength);

	  let i = 0;

	  for (let n = len - (len % 4); i < n; i += 4) {
	    const x = a.getUint32(i, LE);
	    const y = b.getUint32(i, LE);
	    if (x !== y) break
	  }

	  for (; i < len; i++) {
	    const x = a.getUint8(i);
	    const y = b.getUint8(i);
	    if (x < y) return -1
	    if (x > y) return 1
	  }

	  return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0
	}

	function concat (buffers, totalLength) {
	  if (totalLength === undefined) {
	    totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0);
	  }

	  const result = new Uint8Array(totalLength);

	  let offset = 0;
	  for (const buffer of buffers) {
	    if (offset + buffer.byteLength > result.byteLength) {
	      const sub = buffer.subarray(0, result.byteLength - offset);
	      result.set(sub, offset);
	      return result
	    }
	    result.set(buffer, offset);
	    offset += buffer.byteLength;
	  }

	  return result
	}

	function copy (source, target, targetStart = 0, start = 0, end = source.byteLength) {
	  if (end > 0 && end < start) return 0
	  if (end === start) return 0
	  if (source.byteLength === 0 || target.byteLength === 0) return 0

	  if (targetStart < 0) throw new RangeError('targetStart is out of range')
	  if (start < 0 || start >= source.byteLength) throw new RangeError('sourceStart is out of range')
	  if (end < 0) throw new RangeError('sourceEnd is out of range')

	  if (targetStart >= target.byteLength) targetStart = target.byteLength;
	  if (end > source.byteLength) end = source.byteLength;
	  if (target.byteLength - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  const len = end - start;

	  if (source === target) {
	    target.copyWithin(targetStart, start, end);
	  } else {
	    target.set(source.subarray(start, end), targetStart);
	  }

	  return len
	}

	function equals (a, b) {
	  if (a === b) return true
	  if (a.byteLength !== b.byteLength) return false

	  const len = a.byteLength;

	  a = new DataView(a.buffer, a.byteOffset, a.byteLength);
	  b = new DataView(b.buffer, b.byteOffset, b.byteLength);

	  let i = 0;

	  for (let n = len - (len % 4); i < n; i += 4) {
	    if (a.getUint32(i, LE) !== b.getUint32(i, LE)) return false
	  }

	  for (; i < len; i++) {
	    if (a.getUint8(i) !== b.getUint8(i)) return false
	  }

	  return true
	}

	function fill (buffer, value, offset, end, encoding) {
	  if (typeof value === 'string') {
	    // fill(buffer, string, encoding)
	    if (typeof offset === 'string') {
	      encoding = offset;
	      offset = 0;
	      end = buffer.byteLength;

	    // fill(buffer, string, offset, encoding)
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = buffer.byteLength;
	    }
	  } else if (typeof value === 'number') {
	    value = value & 0xff;
	  } else if (typeof value === 'boolean') {
	    value = +value;
	  }

	  if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (offset === undefined) offset = 0;
	  if (end === undefined) end = buffer.byteLength;

	  if (end <= offset) return buffer

	  if (!value) value = 0;

	  if (typeof value === 'number') {
	    for (let i = offset; i < end; ++i) {
	      buffer[i] = value;
	    }
	  } else {
	    value = isBuffer(value) ? value : from(value, encoding);

	    const len = value.byteLength;

	    for (let i = 0; i < end - offset; ++i) {
	      buffer[i + offset] = value[i % len];
	    }
	  }

	  return buffer
	}

	function from (value, encodingOrOffset, length) {
	  // from(string, encoding)
	  if (typeof value === 'string') return fromString(value, encodingOrOffset)

	  // from(array)
	  if (Array.isArray(value)) return fromArray(value)

	  // from(buffer)
	  if (ArrayBuffer.isView(value)) return fromBuffer(value)

	  // from(arrayBuffer[, byteOffset[, length]])
	  return fromArrayBuffer(value, encodingOrOffset, length)
	}

	function fromString (string, encoding) {
	  const codec = codecFor(encoding);
	  const buffer = new Uint8Array(codec.byteLength(string));
	  codec.write(buffer, string, 0, buffer.byteLength);
	  return buffer
	}

	function fromArray (array) {
	  const buffer = new Uint8Array(array.length);
	  buffer.set(array);
	  return buffer
	}

	function fromBuffer (buffer) {
	  const copy = new Uint8Array(buffer.byteLength);
	  copy.set(buffer);
	  return copy
	}

	function fromArrayBuffer (arrayBuffer, byteOffset, length) {
	  return new Uint8Array(arrayBuffer, byteOffset, length)
	}

	function includes (buffer, value, byteOffset, encoding) {
	  return indexOf(buffer, value, byteOffset, encoding) !== -1
	}

	function bidirectionalIndexOf (buffer, value, byteOffset, encoding, first) {
	  if (buffer.byteLength === 0) return -1

	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset === undefined) {
	    byteOffset = first ? 0 : (buffer.length - 1);
	  } else if (byteOffset < 0) {
	    byteOffset += buffer.byteLength;
	  }

	  if (byteOffset >= buffer.byteLength) {
	    if (first) return -1
	    else byteOffset = buffer.byteLength - 1;
	  } else if (byteOffset < 0) {
	    if (first) byteOffset = 0;
	    else return -1
	  }

	  if (typeof value === 'string') {
	    value = from(value, encoding);
	  } else if (typeof value === 'number') {
	    value = value & 0xff;

	    if (first) {
	      return buffer.indexOf(value, byteOffset)
	    } else {
	      return buffer.lastIndexOf(value, byteOffset)
	    }
	  }

	  if (value.byteLength === 0) return -1

	  if (first) {
	    let foundIndex = -1;

	    for (let i = byteOffset; i < buffer.byteLength; i++) {
	      if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === value.byteLength) return foundIndex
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + value.byteLength > buffer.byteLength) {
	      byteOffset = buffer.byteLength - value.byteLength;
	    }

	    for (let i = byteOffset; i >= 0; i--) {
	      let found = true;

	      for (let j = 0; j < value.byteLength; j++) {
	        if (buffer[i + j] !== value[j]) {
	          found = false;
	          break
	        }
	      }

	      if (found) return i
	    }
	  }

	  return -1
	}

	function indexOf (buffer, value, byteOffset, encoding) {
	  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, true /* first */)
	}

	function lastIndexOf (buffer, value, byteOffset, encoding) {
	  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, false /* last */)
	}

	function swap (buffer, n, m) {
	  const i = buffer[n];
	  buffer[n] = buffer[m];
	  buffer[m] = i;
	}

	function swap16 (buffer) {
	  const len = buffer.byteLength;

	  if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')

	  for (let i = 0; i < len; i += 2) swap(buffer, i, i + 1);

	  return buffer
	}

	function swap32 (buffer) {
	  const len = buffer.byteLength;

	  if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')

	  for (let i = 0; i < len; i += 4) {
	    swap(buffer, i, i + 3);
	    swap(buffer, i + 1, i + 2);
	  }

	  return buffer
	}

	function swap64 (buffer) {
	  const len = buffer.byteLength;

	  if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')

	  for (let i = 0; i < len; i += 8) {
	    swap(buffer, i, i + 7);
	    swap(buffer, i + 1, i + 6);
	    swap(buffer, i + 2, i + 5);
	    swap(buffer, i + 3, i + 4);
	  }

	  return buffer
	}

	function toBuffer (buffer) {
	  return buffer
	}

	function toString (buffer, encoding, start = 0, end = buffer.byteLength) {
	  const len = buffer.byteLength;

	  if (start >= len) return ''
	  if (end <= start) return ''
	  if (start < 0) start = 0;
	  if (end > len) end = len;

	  if (start !== 0 || end < len) buffer = buffer.subarray(start, end);

	  return codecFor(encoding).toString(buffer)
	}

	function write (buffer, string, offset, length, encoding) {
	  // write(buffer, string)
	  if (offset === undefined) {
	    encoding = 'utf8';

	  // write(buffer, string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    offset = undefined;

	  // write(buffer, string, offset, encoding)
	  } else if (encoding === undefined && typeof length === 'string') {
	    encoding = length;
	    length = undefined;
	  }

	  return codecFor(encoding).write(buffer, string, offset, length)
	}

	function writeDoubleLE (buffer, value, offset) {
	  if (offset === undefined) offset = 0;

	  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
	  view.setFloat64(offset, value, true);

	  return offset + 8
	}

	function writeFloatLE (buffer, value, offset) {
	  if (offset === undefined) offset = 0;

	  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
	  view.setFloat32(offset, value, true);

	  return offset + 4
	}

	function writeUInt32LE (buffer, value, offset) {
	  if (offset === undefined) offset = 0;

	  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
	  view.setUint32(offset, value, true);

	  return offset + 4
	}

	function writeInt32LE (buffer, value, offset) {
	  if (offset === undefined) offset = 0;

	  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
	  view.setInt32(offset, value, true);

	  return offset + 4
	}

	function readDoubleLE (buffer, offset) {
	  if (offset === undefined) offset = 0;

	  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);

	  return view.getFloat64(offset, true)
	}

	function readFloatLE (buffer, offset) {
	  if (offset === undefined) offset = 0;

	  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);

	  return view.getFloat32(offset, true)
	}

	function readUInt32LE (buffer, offset) {
	  if (offset === undefined) offset = 0;

	  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);

	  return view.getUint32(offset, true)
	}

	function readInt32LE (buffer, offset) {
	  if (offset === undefined) offset = 0;

	  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);

	  return view.getInt32(offset, true)
	}

	module.exports = exports = {
	  isBuffer,
	  isEncoding,
	  alloc,
	  allocUnsafe,
	  allocUnsafeSlow,
	  byteLength,
	  compare,
	  concat,
	  copy,
	  equals,
	  fill,
	  from,
	  includes,
	  indexOf,
	  lastIndexOf,
	  swap16,
	  swap32,
	  swap64,
	  toBuffer,
	  toString,
	  write,
	  writeDoubleLE,
	  writeFloatLE,
	  writeUInt32LE,
	  writeInt32LE,
	  readDoubleLE,
	  readFloatLE,
	  readUInt32LE,
	  readInt32LE
	}; 
} (browser, browser.exports));

var browserExports = browser.exports;
var b4a = /*@__PURE__*/getDefaultExportFromCjs(browserExports);

const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);

let idbProxyableTypes;
let cursorAdvanceMethods;
// This is a function to prevent it throwing up in node environments.
function getIdbProxyableTypes() {
    return (idbProxyableTypes ||
        (idbProxyableTypes = [
            IDBDatabase,
            IDBObjectStore,
            IDBIndex,
            IDBCursor,
            IDBTransaction,
        ]));
}
// This is a function to prevent it throwing up in node environments.
function getCursorAdvanceMethods() {
    return (cursorAdvanceMethods ||
        (cursorAdvanceMethods = [
            IDBCursor.prototype.advance,
            IDBCursor.prototype.continue,
            IDBCursor.prototype.continuePrimaryKey,
        ]));
}
const transactionDoneMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
        const unlisten = () => {
            request.removeEventListener('success', success);
            request.removeEventListener('error', error);
        };
        const success = () => {
            resolve(wrap(request.result));
            unlisten();
        };
        const error = () => {
            reject(request.error);
            unlisten();
        };
        request.addEventListener('success', success);
        request.addEventListener('error', error);
    });
    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
    // is because we create many promises from a single IDBRequest.
    reverseTransformCache.set(promise, request);
    return promise;
}
function cacheDonePromiseForTransaction(tx) {
    // Early bail if we've already created a done promise for this transaction.
    if (transactionDoneMap.has(tx))
        return;
    const done = new Promise((resolve, reject) => {
        const unlisten = () => {
            tx.removeEventListener('complete', complete);
            tx.removeEventListener('error', error);
            tx.removeEventListener('abort', error);
        };
        const complete = () => {
            resolve();
            unlisten();
        };
        const error = () => {
            reject(tx.error || new DOMException('AbortError', 'AbortError'));
            unlisten();
        };
        tx.addEventListener('complete', complete);
        tx.addEventListener('error', error);
        tx.addEventListener('abort', error);
    });
    // Cache it for later retrieval.
    transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
    get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
            // Special handling for transaction.done.
            if (prop === 'done')
                return transactionDoneMap.get(target);
            // Make tx.store return the only store in the transaction, or undefined if there are many.
            if (prop === 'store') {
                return receiver.objectStoreNames[1]
                    ? undefined
                    : receiver.objectStore(receiver.objectStoreNames[0]);
            }
        }
        // Else transform whatever we get back.
        return wrap(target[prop]);
    },
    set(target, prop, value) {
        target[prop] = value;
        return true;
    },
    has(target, prop) {
        if (target instanceof IDBTransaction &&
            (prop === 'done' || prop === 'store')) {
            return true;
        }
        return prop in target;
    },
};
function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
    // Due to expected object equality (which is enforced by the caching in `wrap`), we
    // only create one new func per func.
    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
    // with real promises, so each advance methods returns a new promise for the cursor object, or
    // undefined if the end of the cursor has been reached.
    if (getCursorAdvanceMethods().includes(func)) {
        return function (...args) {
            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
            // the original object.
            func.apply(unwrap(this), args);
            return wrap(this.request);
        };
    }
    return function (...args) {
        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
        // the original object.
        return wrap(func.apply(unwrap(this), args));
    };
}
function transformCachableValue(value) {
    if (typeof value === 'function')
        return wrapFunction(value);
    // This doesn't return, it just creates a 'done' promise for the transaction,
    // which is later returned for transaction.done (see idbObjectHandler).
    if (value instanceof IDBTransaction)
        cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
        return new Proxy(value, idbProxyTraps);
    // Return the same value back if we're not going to transform it.
    return value;
}
function wrap(value) {
    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
    if (value instanceof IDBRequest)
        return promisifyRequest(value);
    // If we've already transformed this value before, reuse the transformed value.
    // This is faster, but it also provides object equality.
    if (transformCache.has(value))
        return transformCache.get(value);
    const newValue = transformCachableValue(value);
    // Not all types are transformed.
    // These may be primitive types, so they can't be WeakMap keys.
    if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
    }
    return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);

/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap(request);
    if (upgrade) {
        request.addEventListener('upgradeneeded', (event) => {
            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
        });
    }
    if (blocked) {
        request.addEventListener('blocked', (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion, event.newVersion, event));
    }
    openPromise
        .then((db) => {
        if (terminated)
            db.addEventListener('close', () => terminated());
        if (blocking) {
            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));
        }
    })
        .catch(() => { });
    return openPromise;
}
/**
 * Delete a database.
 *
 * @param name Name of the database.
 */
function deleteDB(name, { blocked } = {}) {
    const request = indexedDB.deleteDatabase(name);
    if (blocked) {
        request.addEventListener('blocked', (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion, event));
    }
    return wrap(request).then(() => undefined);
}

const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
const writeMethods = ['put', 'add', 'delete', 'clear'];
const cachedMethods = new Map();
function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase &&
        !(prop in target) &&
        typeof prop === 'string')) {
        return;
    }
    if (cachedMethods.get(prop))
        return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, '');
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
        !(isWrite || readMethods.includes(targetFuncName))) {
        return;
    }
    const method = async function (storeName, ...args) {
        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
        let target = tx.store;
        if (useIndex)
            target = target.index(args.shift());
        // Must reject if op rejects.
        // If it's a write operation, must reject if tx.done rejects.
        // Must reject with op rejection first.
        // Must resolve with op value.
        // Must handle both promises (no unhandled rejections)
        return (await Promise.all([
            target[targetFuncName](...args),
            isWrite && tx.done,
        ]))[0];
    };
    cachedMethods.set(prop, method);
    return method;
}
replaceTraps((oldTraps) => ({
    ...oldTraps,
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
}));

const advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];
const methodMap = {};
const advanceResults = new WeakMap();
const ittrProxiedCursorToOriginalProxy = new WeakMap();
const cursorIteratorTraps = {
    get(target, prop) {
        if (!advanceMethodProps.includes(prop))
            return target[prop];
        let cachedFunc = methodMap[prop];
        if (!cachedFunc) {
            cachedFunc = methodMap[prop] = function (...args) {
                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
            };
        }
        return cachedFunc;
    },
};
async function* iterate(...args) {
    // tslint:disable-next-line:no-this-assignment
    let cursor = this;
    if (!(cursor instanceof IDBCursor)) {
        cursor = await cursor.openCursor(...args);
    }
    if (!cursor)
        return;
    cursor = cursor;
    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
    // Map this double-proxy back to the original, so other cursor methods work.
    reverseTransformCache.set(proxiedCursor, unwrap(cursor));
    while (cursor) {
        yield proxiedCursor;
        // If one of the advancing methods was not called, call continue().
        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
        advanceResults.delete(proxiedCursor);
    }
}
function isIteratorProp(target, prop) {
    return ((prop === Symbol.asyncIterator &&
        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||
        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));
}
replaceTraps((oldTraps) => ({
    ...oldTraps,
    get(target, prop, receiver) {
        if (isIteratorProp(target, prop))
            return iterate;
        return oldTraps.get(target, prop, receiver);
    },
    has(target, prop) {
        return isIteratorProp(target, prop) || oldTraps.has(target, prop);
    },
}));

const posix = makePath(false);
const win32 = makePath(true);

posix.win32 = win32;
win32.posix = posix;

var tinyPaths = process.platform === 'win32' ? win32 : posix;

function makePath (windows) {
  const path = {};

  path.posix = path;
  path.win32 = path;

  const sep = path.sep = windows ? '\\' : '/';

  if (windows) {
    path.isAbsolute = function isAbsolute (p) {
      if (p.length === 0) return false
      return (p[0] === '\\' || p[0] === '/') ||
        (p.length === 2 && p[1] === ':') ||
        (p.length > 2 && p[1] === ':' && (p[2] === '\\' || p[2] === '/'))
    };

    path.root = function root (p) {
      if (p.length === 0) return ''

      return (p[0] === '\\' || p[0] === '/')
        ? p[0]
        : (p.length === 2 && p[1] === ':')
            ? p
            : (p.length > 2 && p[1] === ':' && (p[2] === '\\' || p[2] === '/'))
                ? p.slice(0, 3)
                : ''
    };
  } else {
    path.isAbsolute = function isAbsolute (p) {
      return p.length > 0 && p[0] === '/'
    };

    path.root = function root (p) {
      return path.isAbsolute(p) ? '/' : ''
    };
  }

  path.basename = function basename (p) {
    let end = p.length - 1;
    while (end > 0 && p[end] === sep) end--;
    if (end <= 0) return ''
    return p.slice(p.lastIndexOf(sep, end) + 1, end + 1)
  };

  path.dirname = function dirname (p) {
    let end = p.length - 1;
    while (end > 0 && p[end] === sep) end--;
    if (end <= 0) return ''
    const start = p.lastIndexOf(sep, end);
    if (start === -1) return ''
    return p.slice(0, start)
  };

  path.extname = function extname (p) {
    const i = p.lastIndexOf('.');
    return i === -1 ? '' : p.slice(i)
  };

  path.resolve = function resolve (a, b) {
    if (b === undefined) return path.normalize(a)
    if (path.isAbsolute(b)) return path.normalize(b)
    return path.join(a, b)
  };

  path.join = function join (p, ...parts) {
    for (const part of parts) p += sep + part;
    return path.normalize(p)
  };

  path.normalize = function normalize (p) {
    if (windows === true) {
      let i = -1;
      while ((i = p.indexOf('/', i + 1)) !== -1) p = p.slice(0, i) + sep + p.slice(i + 1);
    }

    const root = path.root(p);
    const isAbsolute = root !== '';

    let i = root.length;
    let out = '';

    while (i < p.length) {
      let j = p.indexOf(sep, i);

      if (j === -1) j = p.length;

      const part = p.slice(i, j);
      i = j + 1;

      if (part === '') {
        continue
      }

      if (part === '.') {
        continue
      }

      if (part === '..') {
        const l = out.lastIndexOf(sep);
        if (l === -1 || out.slice(l + 1) === '..') {
          if (isAbsolute) out = '';
          else out += out ? sep + '..' : '..';
        } else {
          out = out.slice(0, l);
        }
        continue
      }

      out += out ? sep + part : part;
    }

    if (root) out = root + out;

    return out || '.'
  };

  return path
}

var path = /*@__PURE__*/getDefaultExportFromCjs(tinyPaths);

/*
Copyright (c) 2015-2020, Matteo Collina <matteo.collina@gmail.com>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

var n=function(n){var e=new n,t=e;return {get:function(){var r=e;return r.next?e=r.next:(e=new n,t=e),r.next=null,r},release:function(n){t.next=n,t=n;}}};
var e={exports:{}},r=n;function t(n,e,t){if("function"==typeof n&&(t=e,e=n,n=null),!(t>=1))throw new Error("fastqueue concurrency must be equal to or greater than 1");var a=r(l),o=null,i=null,c=0,s=null,f={push:function(r,l){var h=a.get();h.context=n,h.release=d,h.value=r,h.callback=l||u,h.errorHandler=s,c>=t||f.paused?i?(i.next=h,i=h):(o=h,i=h,f.saturated()):(c++,e.call(n,h.value,h.worked));},drain:u,saturated:u,pause:function(){f.paused=!0;},paused:!1,get concurrency(){return t},set concurrency(n){if(!(n>=1))throw new Error("fastqueue concurrency must be equal to or greater than 1");if(t=n,!f.paused)for(;o&&c<t;)c++,d();},running:function(){return c},resume:function(){if(!f.paused)return;for(f.paused=!1;o&&c<t;)c++,d();},idle:function(){return 0===c&&0===f.length()},length:function(){var n=o,e=0;for(;n;)n=n.next,e++;return e},getQueue:function(){var n=o,e=[];for(;n;)e.push(n.value),n=n.next;return e},unshift:function(r,l){var h=a.get();h.context=n,h.release=d,h.value=r,h.callback=l||u,h.errorHandler=s,c>=t||f.paused?o?(h.next=o,o=h):(o=h,i=h,f.saturated()):(c++,e.call(n,h.value,h.worked));},empty:u,kill:function(){o=null,i=null,f.drain=u;},killAndDrain:function(){o=null,i=null,f.drain(),f.drain=u;},error:function(n){s=n;}};return f;function d(r){r&&a.release(r);var u=o;u&&c<=t?f.paused?c--:(i===o&&(i=null),o=u.next,u.next=null,e.call(n,u.value,u.worked),null===i&&f.empty()):0==--c&&f.drain();}}function u(){}function l(){this.value=null,this.callback=u,this.next=null,this.release=u,this.context=null,this.errorHandler=null;var n=this;this.worked=function(e,r){var t=n.callback,l=n.errorHandler,a=n.value;n.value=null,n.callback=u,n.errorHandler&&l(e,a),t.call(n.context,e,r),n.release(n);};}e.exports=t;var a=e.exports.promise=function(n,e,r){"function"==typeof n&&(r=e,e=n,n=null);var l=t(n,(function(n,r){e.call(this,n).then((function(n){r(null,n);}),r);}),r),a=l.push,o=l.unshift;return l.push=function(n){var e=new Promise((function(e,r){a(n,(function(n,t){n?r(n):e(t);}));}));return e.catch(u),e},l.unshift=function(n){var e=new Promise((function(e,r){o(n,(function(n,t){n?r(n):e(t);}));}));return e.catch(u),e},l.drained=function(){if(l.idle())return new Promise((function(n){n();}));var n=l.drain;return new Promise((function(e){l.drain=function(){n(),e();};}))},l};

var tinyEmitter = {exports: {}};

function E () {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    }
    listener._ = callback;
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

tinyEmitter.exports = E;
tinyEmitter.exports.TinyEmitter = E;

var tinyEmitterExports = tinyEmitter.exports;
var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(tinyEmitterExports);

const metaDb = await openDB("###meta", undefined, {
    upgrade(db) {
        const dataStore = db.createObjectStore('meta', {
            keyPath: 'fileName',
            autoIncrement: false,
        });

        dataStore.createIndex("length", "length");
        dataStore.createIndex("type", "type");
        dataStore.createIndex("chunkSize", "chunkSize");
    }
});

function delMetaOfFile(fileName) {
    const tx = metaDb.transaction("meta", "readwrite");
    const store = tx.objectStore('meta');
    return store.delete(fileName).then(async (x) => {
        await tx.done;
        return x;
    }).catch(e => {
        console.log("Failed to del meta", e);
        return false;
    });
}

function getMetaOfFile(fileName) {
    const tx = metaDb.transaction("meta", "readonly");
    const store = tx.objectStore('meta');

    return store.get(fileName).then(
        async (result) => {
            await tx.done;
            return result;
        }
    ).catch(e => {
        console.log("Failed to get meta", e);
        return false;
    })
}

async function setMetaOfFile(meta) {
    const tx = metaDb.transaction("meta", "readwrite");
    const store = tx.objectStore("meta");
    await store.put(meta);
    return tx.done;
}

async function openFile(fileName, config = {}) {
    const {
        openBlockingHandler,
        openBlockedHandler
    } = config;
    if (fileName === "######meta") {
        throw new Error("Reserved db name");
    }
    return await openDB(fileName, undefined, {
        upgrade(db) {
            const dataStore = db.createObjectStore('chunks', {
                // The 'id' property of the object will be the key.
                keyPath: 'chunk',
                // If it isn't explicitly set, create a value by auto incrementing.
                autoIncrement: false,
            });

            dataStore.createIndex("data", "data");
        },
        blocking(currentVersion, blockedVersion, event) {
            openBlockingHandler(currentVersion, blockedVersion, event);
        },
        blocked(...args) {
            openBlockedHandler(...args);
        }
    });
}

async function getChunks(db, range = {}, inclusiveLow = true, inclusiveHigh = true) {
    const tx = db.transaction("chunks", "readonly");
    const store = tx.objectStore('chunks');

    let keyRange;

    if (range.end == null)
        keyRange = IDBKeyRange.lowerBound(range.start, !inclusiveHigh);
    else if (range.start == null)
        keyRange = IDBKeyRange.upperBound(range.end, !inclusiveLow);
    else if (range.start && range.end) {
        keyRange = IDBKeyRange.bound(range.start, range.end, !inclusiveLow, !inclusiveHigh);
    } else {
        keyRange = undefined;
    }

    const results = await store.getAll(keyRange);
    await tx.done;
    return results;
}

async function setChunks(db, chunkBook = []) {
    if (!Array.isArray(chunkBook)) chunkBook = [chunkBook];
    const tx = db.transaction("chunks", "readwrite");
    const store = tx.objectStore('chunks');
    const promises = [];
    for (const {chunk, data} of chunkBook) {
        promises.push(
            store.put(
                {
                    chunk,
                    data
                }
            )
        );
    }
    promises.push(tx.done);
    await Promise.all(promises);
}

// todo: Error handling testing. Currently, unlikely
//       indexeddb errors have not been tested
/**
 * Current default configurations.
 * @type {{chunkSize: number, MapClass: MapConstructor, dbSeparator: string}}
 */
let defaultConfig = {
    chunkSize: 4096, MapClass: Map
};

/**
 * Update default configurations for all further database creations.
 *
 * @example
 * updateDefaultConfig(existingConfig => ({...existingConfig, chunkSize: 1024, MapClass: ObservableMap}));
 *
 * @param cb
 * @returns {Promise<void>}
 */
function updateDefaultConfig(cb) {
    return Promise.resolve(cb(defaultConfig)).then((changedConfig) => {
        defaultConfig = changedConfig;
    })
}

/**
 * Get a map of all loaded files.
 */
let allLoadedFiles = null;

/**
 * Create a random access idb instance
 *
 * @example // File creation example
 *
 * const rai = createFile("helloWorld.txt");
 * rai.write(0, Buffer.from("hello world!!!"));
 *
 * @param [fileName] The name of the file
 * @param [config] Optional configurations
 * @param [config.chunkSize=4096] The chunk size of the files created from the created database.
 * Chunk size will be stored in the file's metadata and used for the next open.
 * @param [config.size=4096] Alias of {@link config.chunkSize}
 * @param [config.openBlockingHandler] Handler in the case that another tab, process, or part of the code tries to open
 * the same file. Default behavior is to close if this instance blocks another instance
 * @param [config.openBlockedHandler] If this instance encounters a block by another instance (tab, process, etc), how
 * to handle it. Default, does nothing and waits for the other process to close the file.
 * @param [config.deleteBlockingHandler] In the case where this instance wants to delete (purge) the file, but is blocked
 * by another instance operating on it. Default behavior is to do nothing and wait.
 * @param [config.MapClass] A custom map class to use for file listing instead of the native map class. Default is native map class.
 * @param [config.directory] Put the files into directory.
 * @returns Function<RandomAccessIdb>
 */
function createFile(fileName, config = {}) {
    const {
        size,
        chunkSize = size,
        MapClass,
        openBlockingHandler = (currVer, blockedVer, event) => {
            console.warn("Closed due to blocking.", fileName);
            allLoadedFiles.get(fileName)?.close();
            return event.target.close();
        },
        openBlockedHandler,
        deleteBlockingHandler,
        prefix,
        directory = prefix
    } = ({...defaultConfig, ...config});
    if (directory) fileName = path.join(directory, path.resolve('/', fileName).replace(/^\w+:\\/, ''));
    if (!allLoadedFiles) allLoadedFiles = new MapClass();
    if (allLoadedFiles.has(fileName)) {
        const ras = allLoadedFiles.get(fileName);
        if (ras.closed) {
            delete allLoadedFiles.delete(fileName);
        } else {
            return ras;
        }
    }

    config.chunkSize ||= chunkSize;
    const ready = () => openFile(fileName, {openBlockingHandler, openBlockedHandler, ...config});

    const ras = new RandomAccessIdb({ready, fileName, ...config});
    ras.deleteBlockingHandler = deleteBlockingHandler;
    allLoadedFiles.set(fileName, ras);
    return ras;
}

/**
 * @class RandomAccessIdb
 * @extends RandomAccessStorage
 * @see https://github.com/random-access-storage/random-access-storage
 * @property {Number} length
 * Total length of the file
 * @property {String} fileName
 * The fileName of the file
 * @property {number} chunkSize
 * The chunk size this file is stored on the database.
 * @property {string} key
 * The key this file uses in allLoadedFiles map.
 */
class RandomAccessIdb extends EventEmitter {
    constructor({ready, fileName, chunkSize}) {
        super();
        this.ready = ready;
        this.suspended = false;
        this.opened = false;
        this.closed = true;
        this.meta = {
            fileName,
            chunkSize,
            length: 0
        };
        this._startQ();
    }

    get fileName() {
        return this.meta.fileName;
    }

    get length() {
        // console.log("Retrieved length", this.meta);
        return this.meta.length || 0;
    }

    get chunkSize() {
        return this.meta.chunkSize;
    }

    async getMeta() {
        const storedMeta = await getMetaOfFile(this.fileName) || {};
        this.meta = {...this.meta, ...storedMeta};

    }

    async saveMeta() {
        return setMetaOfFile(
            this.meta
        );
    }

    async setLength(length) {
        this.meta.length = length;
        // console.log("Setting length", length, this.meta);
        return this.saveMeta();
    }

    _startQ() {
        const self = this;
        if (this.queue) return;
        let timer, stallTimeout = 10000;
        this.queue ||= a(
            async ({task, request}) => {
                try {
                    // Needs to run each time, to ensure we have any updates
                    // from other processes/tabs.
                    if (!self.opened) {
                        await self.__open;
                    }
                    timer = setTimeout(() => {
                        console.error("The queue stalled", {task, request});
                    }, stallTimeout);
                    const result = await Promise.resolve(task());
                    if (request.callback) await request.callback(null, result);
                    return result;
                } catch (e) {
                    if (request.callback) return request.callback(e);
                    throw e;
                } finally {
                    if (timer) clearTimeout(timer);
                }
            }, 1
        );
    }

    /**
     * Purge the file from the table.
     * 'Closes' the file from allFilesOpened map.
     *
     * @param cb (error) => {}
     */
    async purge(cb) {
        const self = this;
        await new Promise(resolve => self.close(resolve));
        await deleteDB(self.fileName, {
            blocked(...args) {
                if (self.deleteBlockingHandler) self.deleteBlockingHandler(...args);
            }
        });
        await delMetaOfFile(self.fileName);
        await this.close();
        cb?.();
    }

    _blocks(i, j) {
        return blocks(this.chunkSize, i, j)
    }

    async __open() {
        // Due to the way indexeddb can potentially operate across
        // multiple tabs, and be closed at any moment notice open is
        // called pretty much every op.
        const self = this;
        // Need to detect when the db closes unexpectedly.
        if (this.opened && !this.closed && !this.suspended) return;
        self.db = await self.ready();
        await self.getMeta();
        if (self.suspended) {
            self.emit("unsuspend");
            self.suspended = false;
            self.queue.resume();
        }
        if (!self.opened)
            self.emit("open", this);
        self.closed = false;
        self.opened = true;
    }

    open(cb = noop) {
        this.__open().then(cb);
    }

    read(offset, size, cb = noop) {
        const self = this;
        this.open(() => {
            self.queue.push(
                {
                    request: {
                        callback: cb
                    },
                    async task() {
                        if (size === 0) return b4a.alloc(0);

                        const {
                            db, length
                        } = self;

                        if (length === 0) {
                            const error = new Error("No file");
                            error.code = "ENOENT";
                            throw error;
                        }
                        if (size === Number.POSITIVE_INFINITY) size = length - offset;
                        if ((length || 0) < offset + size) {
                            throw new Error('Could not satisfy length ');
                        }
                        const blocks = self._blocks(offset, offset + size);
                        const [{block: firstBlock}] = blocks;
                        const {block: lastBlock} = blocks[blocks.length - 1];

                        const chunks = await getChunks(db, {
                            start: firstBlock,
                            end: lastBlock
                        }, true, true);

                        if (!chunks.length) return b4a.alloc(0);

                        let cursor = 0;

                        const map = [];
                        for (const {data, chunk} of Object.values(chunks)) {
                            cursor = chunk - firstBlock;
                            if (!blocks[cursor]) {
                                continue;
                            }
                            const {start, end} = blocks[cursor];
                            map[cursor] = b4a.from(data.slice(start, end));
                        }
                        return b4a.from(b4a.concat(map))
                    }
                }
            );
        });
    }

    write(offset, data, cb = noop) {
        const self = this;
        this.open(() => {
            self.queue.push({
                request: {callback: cb},
                async task() {
                    const {
                        chunkSize, length, db
                    } = self;

                    const blocks = self._blocks(offset, offset + data.length);
                    const [{block: firstBlock}] = blocks;
                    const {block: lastBlock} = blocks[blocks.length - 1];
                    let newLength;

                    const chunks = await getChunks(db, {
                        start: firstBlock,
                        end: lastBlock
                    }, true, true);

                    for (let [key, value] of Object.entries(chunks)) {
                        chunks[key] = value?.data;
                    }

                    let cursor = 0;
                    let i = 0;

                    const tx = db.transaction("chunks", "readwrite");
                    const store = tx.objectStore('chunks');

                    for (const {block, start, end} of blocks) {
                        const blockPos = i++;
                        const blockRange = end - start;

                        if (blockRange === chunkSize) {
                            chunks[blockPos] = b4a.from(data.slice(cursor, cursor + blockRange));
                        } else {
                            chunks[blockPos] ||= b4a.from(b4a.alloc(chunkSize));
                            b4a.copy(b4a.from(data), chunks[blockPos], start, cursor, cursor + blockRange);
                        }
                        await store.put({chunk: block, data: b4a.from(chunks[blockPos])});
                        cursor += blockRange;
                    }

                    newLength = Math.max(length || 0, offset + data.length);
                    await tx.done;
                    await self.setLength(newLength);
                    return null;
                }
            });
        });
    }

    del(offset, size, cb = noop) {
        const self = this;
        this.open(() => {
            const {
                length
            } = self;

            if (size === Number.POSITIVE_INFINITY) size = length - offset;

            if (offset + size > length) {
                size = Math.max(0, length - offset);
            }
            if (offset + size >= length) {
                return self.truncate(offset, cb);
            }

            self.queue.push(
                {
                    request: {
                        callback: cb
                    },
                    async task() {
                        const {
                            db, chunkSize
                        } = self;
                        const blocks = self._blocks(offset, offset + size);
                        const firstBlock = blocks.shift();
                        const lastBlock = blocks.pop() || firstBlock;
                        const deleteBlockCount = lastBlock.block - firstBlock.block;

                        if (deleteBlockCount > 1) {
                            await getChunks(db, {
                                start: firstBlock.block,
                                end: lastBlock.block
                            }, false, false);
                        }

                        const {0: first, 1: last} = await getChunks(db, {
                            start: firstBlock.block,
                            end: lastBlock.block
                        }, true, true);


                        if (first) {
                            const end = last ? firstBlock.end : firstBlock.end - firstBlock.start;
                            const empty = b4a.alloc(end);
                            b4a.copy(empty, first.data, firstBlock.start);
                            await setChunks(db, first);
                        }

                        if (last) {
                            const end = Math.min(lastBlock.end, chunkSize);
                            const empty = b4a.alloc(end);
                            b4a.copy(empty, last.data, lastBlock.start);
                            await setChunks(db, last);
                        }
                    }
                }
            );
        });
    }

    suspend(cb) {
        const self = this;
        this.queue.pause();
        this.suspended = true;
        setTimeout(() => {
            self.emit("suspend");
            cb();
        });
    }

    truncate(offset, cb = noop) {
        const self = this;
        this.open(() => {
            const {
                length
            } = self;
            if (offset === length) {
                // nothing
                return cb(null, null);
            } else if (offset > length) {
                // grow
                // console.log("growing", self.fileName);
                return self.write(length, b4a.alloc(offset - length), (err) => {
                    if (err) return cb(err, null);
                    return cb(null, null);
                });
            }

            self.queue.push({
                request: {
                    callback: cb
                },
                async task() {
                    const {
                        length, chunkSize, db
                    } = self;
                    // Shrink
                    const blocks = self._blocks(offset, length);
                    const [{block: firstBlock, start, end}] = blocks;

                    const [firstChunk, ...restChunks] = await getChunks(db, {
                        start: firstBlock
                    }, true);
                    const tx = db.transaction("chunks", "readwrite");
                    const store = tx.objectStore('chunks');
                    if (restChunks.length > 0) {
                        const ops = [];
                        for (const chunk of restChunks) {
                            ops.push(
                                store.delete(chunk.chunk)
                            );
                        }
                        await Promise.all(ops);
                    }

                    const blockRange = end - start;
                    if (blockRange === chunkSize) {
                        await store.delete(firstBlock);
                    } else {
                        let {data, chunk} = firstChunk;
                        let truncatedData = b4a.alloc(blockRange);
                        b4a.copy(truncatedData, data, start, start, blockRange);
                        await store.put({
                            chunk, data
                        });
                    }
                    await tx.done;
                    await self.setLength(offset);
                    return null;
                }
            });
        });
    }

    stat(cb = noop) {
        const self = this;
        this.open((e) => {
            if (e) return cb(e);
            this.queue.push({
                request: {callback: cb},
                task() {
                    return {
                        fileName: self.fileName,
                        length: self.length,
                        size: self.length,
                        chunkSize: self.chunkSize,
                        blksize: self.chunkSize
                    };
                }
            });
        });
    }

    close(cb = noop) {
        const self = this;

        this.open(() => {
            self.queue.push({
                async task() {
                    if (!self.closed) self.emit("close");
                    else return cb(null);
                    self.closed = true;
                    self.opened = false;
                    self.db.close();
                    allLoadedFiles.delete(self.fileName);
                },
                request: {
                    callback: cb
                }
            });
        });

    }
}

function noop() {
    return () => null
}

export { allLoadedFiles, createFile, createFile as default, defaultConfig, updateDefaultConfig };
